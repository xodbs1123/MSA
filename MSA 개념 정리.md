개념, 사례 (성공, 실패), 면접 질문

## MSA (Microservice Architecture) 개념 ##
- 하나의 큰 애플리케이션을 **여러 개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능**하도록 만든 아키텍처
- 예로, '인증'을 담당하는 서비스(auth.example.com)의 구체적인 구현 내용을 모르더라도, 다른 서비스에서 약속된 인터페이스를 이용하여 해당 인증 서비스를 사용 가능
- 갑자기 등장한 개념은 아니지만, **REST API의 일반화, 도커와 같은 컨테이너 기술, 클라우드 컴퓨팅 환경 발전** 등에 힘입어 손쉽게 구현될 수 있게 되었음

![image](https://github.com/xodbs1123/MSA/assets/61976898/f1c4df59-d614-4969-9294-5319d5af6beb)

## MSA는 언제 필요한가? ##
- 모든 애플리케이션이 MSA 패턴으로 구성될 필요는 없음
- 어떤 서비스와 컴포넌트(Component)가 필요하게 될 지 예측할 수 없는 상황에서 시스템을 과도하게 쪼갤 필요는 없음
- 아래와 같은 상황에서는 MSA를 고려해볼 필요가 있음
<br><br>
**1. 애플리케이션의 배포에 한 시간 이상 소요된다.** <br><br>
**2. 단순한 기능 하나를 수정해도 전체 기능에 대한 QA(Quality Assurance)가 필요하다.** <br><br>
**3. 단순한 버그 수정이 더 중대한 버그를 생산하는 일이 많아졌다.** <br><br>
**4. 현재의 애플리케이션을 기능별로 나눈다고 가정했을 때 수십개의 마이크로서비스가 가능하다.** 
<br><br>


## MSA 장단점 ###
### 장점 ###
- MSA의 각 서비스는 독립적이고 새로운 프로젝트이며 요구사항에 맞는 프로그래밍 언어로 사용해서 개발 가능
- 개발자는 특정 서비스만 집중하기 때문에 코드 저장소는 매우 작을 것이고 해당 코드에 집중할 수 있음
- 각 서비스가 통신이 필요할 때 API(REST 서비스에 의해)를 통해 통신할 수 있음
- 각 모듈은 각자의 데이터베이스를 가지고 있기 때문에 중앙화된 데이터베이스가 없음 = 장애 범위 축소

### 단점 ###
- 큰 프로젝트에는 많은 서비스들이 있고, 이러한 서비스들을 모니터링하는 것은 오버헤드를 증가시킴
- 서비스가 장애가 나는 경우 추적하기 어려울 수 있음
- 서비스는 다른 서비스를 호출하기 때문에 경로를 추적하고 디버깅하는 것이 어려움
- 각 서비스는 각각의 로그를 생성하기 때문에 중앙 로그 모니터링이 없음, 별도 로그 관리 시스템 필요
- 모놀리스 소프트웨어(Monolith Software)의 프로세스간 통신에 비해 조금 더 큰 오버헤드를 가진 API/원격 호출을 통해 통신

## MSA 성공 사례 ##
**[배달의민족 MSA 여행기]** 
https://sihyung92.oopy.io/architecture/woowa-msa-travel
<br><br>
**1. 시스템 신뢰성 향상** 
   - 시스템 일부 장에애 대한 저항력을 키워 시스템 신뢰성이 향상
<br><br>

**2. 자유로운 스케일링 가능**
   - 리뷰 작성 이벤트, 쿠폰 이벤트 등 각 부문별에 증가할 트래픽에 맞서 자유로운 스케일링(Up & Out)이 가능해짐

## MSA 실패 사례 ##
**["마이크로서비스는 답이 아니었다"··· 세그먼트가 모놀리틱으로 돌아온 이유]**
https://www.ciokorea.com/news/39258#csidxf22d795897aeb5d918abdae40ae8c0b 

**1. MSA의 과도한 분산** 
   - 개발자들은 각각의 파트너 API와 서비스를 관리해야했고, 이로 인해 업데이트 및 버전 관리가 어려워졌으며, 서로 다른 라이브러리 버전을 관리하는 어려움 발생
<br><br>

**2. 성능 및 확장성 문제** 
   - 다양한 목적지의 대규모 이벤트를 처리해야 했지만, 각 목적지는 다른 CPU 및 메모리 로드 패턴을 가지고 있었고, 이로 인해 통합된 규칙 적용이 어려워져 성능 문제 발생
<br><br>

**3. 개발자 생산성 감소** 
   - MSA 복잡성으로 인해 개발자들은 개발 생산성이 감소하였고, 업데이트 및 관리 작업이 번거로워짐<br><br>

<br><br>
   **<결론>**  <br><br> 
   => 단일 구조로 돌아갔고 개발자 생산성 증대 및 서비스 전개 시간도 수 분 이내로 단축<br><br>
   => 공유 라이브러리에 업데이트를 생성하고 싶을 때, 엔지니어 1명이 한 시간만 투자해 테스트하고 전개 가능해짐
